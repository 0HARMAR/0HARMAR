### 参数传递
前 6 个整数或指针类型参数 使用以下寄存器传递：

第 1 个参数：%rdi  
第 2 个参数：%rsi  
第 3 个参数：%rdx  
第 4 个参数：%rcx  
第 5 个参数：%r8  
第 6 个参数：%r9  
如果有超过 6 个参数，多余的参数通过栈传递（从右到左的顺序入栈）。

### 返回值

函数返回值通过 %rax 寄存器传递。
如果返回值是更复杂的类型（如结构体），通常会通过指针返回。

### 被调用者保存（Callee-Saved）寄存器
被调用的函数需要保存并恢复以下寄存器的内容（如果函数修改了它们）：
%rbx, %rsp, %rbp, %r12, %r13, %r14, %r15
**被调用者如果修改了这些寄存器的值，需要在函数返回之前将这些寄存器的值恢复原状**

### 调用者保存（Caller-Saved）寄存器
除了被调用者保存寄存器外都是调用者保存
**被调用者可以随意使用它们，保存这些寄存器的值是调用者的责任**

### 栈对齐
调用函数之前，栈指针 %rsp 必须对齐到 16 字节边界。
如果需要通过栈传递额外的参数，调用者负责对齐
### 返回地址
调用函数时，call 指令会将返回地址压入栈中（通过 ret 返回）。


### 示例程序
[att函数调用](file:\\\C:\Just-For-Fun\ASM\learn\func_call.asm)

### 函数调用基本过程
1. 调用者准备参数
2. 调用函数(call func_name)
3. 将返回地址压入栈(返回地址即调用者下一条指令)
4. 跳入目标函数($rip = &func_name)
5. push $rbp,保存caller的栈帧基指针
6. mov $rsp , $rbp,将基地址寄存器rbp设为当前函数开始地址
7. 函数结束时，mov $rbp , $rsp将栈指针恢复到caller开始调用的位置，也就是清理栈
8. pop $rbp,将基地址寄存器的值设置为caller原来的基地址
9. ret,$rip = ret_addr，and pop ret_addr