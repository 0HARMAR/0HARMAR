# 指令编码规则

## 指令格式

指令编码由两个字节和（可能）更多的字节组成：

1. **第一字节**：指令编号（最大支持 256 个指令）
2. **第二字节**：操作寄存器（最大支持 16 个通用寄存器）
3. **第三字节及之后的字节**：常量或地址（视指令类型而定）

## 第一字节：指令编号

| 编码        | 指令  |
|-------------|-------|
| `00000000`  | `mov` |
| `00000001`  | `add` |
| `00000010`  | `sub` |
| `00000011`  | `push`|
| `00000101`  | `call`|
| `00000110`  | `ret` |

## 第二字节：操作寄存器

| 编码   | 寄存器 |
|--------|--------|
| `0001` | `r1`   |
| `0010` | `r2`   |
| `0011` | `r3`   |
| `0100` | `r4`   |
| `0101` | `r5`   |
| `0110` | `r6`   |
| `0111` | `r7`   |
| `1000` | `r8`   |
| `1001` | `r9`   |
| `1010` | `r10`  |
| `1011` | `r11`  |
| `1100` | `r12`  |
| `1101` | `r13`  |
| `1110` | `r14`  |
| `1111` | `r15`  |

## 示例

### 1. `mov $1 r1`

该指令将一个立即数 `1` 移动到寄存器 `r1` 中。编码格式如下：

| 第一字节   | 第二字节   | 第三字节及之后的字节                        |
|------------|------------|---------------------------------------------|
| `00000000` | `00000001` | `00000001 00000000 00000000 00000000`       |

### 2. `add r1 to r2`

该指令将寄存器 `r1` 的值加到寄存器 `r2` 中。编码格式如下：

| 第一字节   | 第二字节   | 第三字节及之后的字节                        |
|------------|------------|---------------------------------------------|
| `00000001` | `00000010` | `00000000 00000000 00000000 00000000`       |

### 3. `push r1`

该指令将 `r1` 寄存器的值保存到栈上。编码格式如下：

| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00000011` | `00000001` (前四位为 0，后四位为目标寄存器) | `00000000 00000000 00000000 00000000` |

### 4. `call r1`

该指令跳转到寄存器 `r1` 存储的地址，同时将返回地址放入栈中。编码格式如下：

| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00000101` | `00000001` (前四位为 0，后四位为目标寄存器 r1) | `00000000 00000000 00000000 00000000` |

### 5. `call $10`

该指令跳转到绝对地址 `10`，同时将返回地址放入栈中。编码格式如下：

| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00000101` | `00000000` (无操作寄存器) | `00000000 00000000 00000000 00001010` |

### 6. `ret`

该指令从栈中弹出返回地址，并跳转到该地址。编码格式如下：

| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00000110` | `00000000` (无操作寄存器) | `00000000 00000000 00000000 00000000` |

### 7. `jmp $6`（跳转到指定地址）

该指令将跳转到绝对地址 `6`，继续执行程序流。由于 `jmp` 是无条件跳转指令，不涉及寄存器操作，因此指令编码如下：

| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00000111` | `00000000` (无操作寄存器) | `00000000 00000000 00000000 00000110` |

### 8. `itr`（触发中断）

`itr` 指令用于触发中断,由于 `itr` 指令不涉及操作寄存器，因此第二字节全部为 `0`，第三字节及之后用于指定中断号。

#### 指令格式
| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00001000` | `00000000` (无操作寄存器) | 中断号（四字节表示） |

### 示例：`itr 15`（触发中断号 `15`）

以下是触发中断号 `15` 的 `itr` 指令编码：

| 第一字节   | 第二字节              | 第三字节及之后的字节 |
|------------|-----------------------|----------------------|
| `00001000` | `00000000`             | `00000000 00000000 00000000 00001111` |

## 支持的数据传送

1. 立即数 -> 寄存器(内存)
2. 寄存器 -> 寄存器(内存)

